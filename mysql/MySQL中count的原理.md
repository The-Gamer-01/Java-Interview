# COUNT()的实现方式
在不同的引擎中，count函数也有不同的实现方式；
在MyISAM引擎中，将一个表的总行数直接存储到了磁盘中，查询的时候直接返回该值即可，所以很快；
而在Innodb引擎中，count是动态统计的，所以在数据量大的时候，查询效率十分低下；
Innodb因为支持多版本控制（MVCC），所以他将一个表的总行数存储到硬盘，其行值不一定准确可靠；
## 如何加快COUNT()
一、缓存
我们可以很容易想到，我们可以用redis做缓存，来存储表的行数
插入一行数据，就行数加一；删除一条数据，就行数减一；
但是redis有可能丢失更新；在插入一条数据时，redis加一，但是redis异常重启了，我们需要恢复redis的数据，但是加一的数据却丢失了；
我们可以在每次异常重启的时候，查询一次MySQL，这样就不会有丢失更新的问题；

但是redis存储行数会有逻辑上的精确度问题，原因是因为，我们没有办法在代码层面保证是redis先加一还是数据先插入数据库中，所以缓存不能存储表的行数；

二、把行数保存在MySQL中
因为MySQL的redolog机制，所以保证了不会有丢失更新的问题；
我们可以通过事务来解决redis中会出现的精确度问题，因为事务与事务之间不可见；

## COUNT的多种用法
常见的COUNT的用法有COUNT(*),COUNT(字段),COUNT(1),COUNT(主键ID)四种；

我们来一一分析这四种用法
### COUNT(主键ID)
COUNT(主键ID)的用法，其实相当于是一行一行把数据取出来，即遍历整张表返回给server层，server层拿到id，但是因为主键ID不可能重复，所以我们直接加一；

### COUNT(1)
COUNT(1)的用法，相当于走主键索引树，但是不把索引树所对应的节点的数据取值，而是server层对于返回的每一行放一个数字1，判断不可能为空，按行累加；

### COUNT(字段)
COUNT(字段)的话，我们就需要分析一下：
一、字段不能为空
不能为空的话，其实也是按行累加
二、字段可以为空
字段可以为空的话，我们还需要先判断一下字段是否为空，不为空我们才加一；

### COUNT(*)

其实MySQL中，COUNT(*)进行了优化操作，他不会把所有字段取出来，我们都知道，普通索引是比主键索引小的，所以优化器会让COUNT(*)自动选择索引树进行遍历计数；

所以理论上，按照效率排序：
COUNT(字段)<COUNT(主键ID)<COUNT(1)≈COUNT(*)
